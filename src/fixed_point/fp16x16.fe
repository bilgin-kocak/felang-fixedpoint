// use utils::xor

// Fixed point 16.16
// 16 bits for the integer part, 16 bits for the fractional part
// 1 bit for the sign
// 


pub struct FP16x16 {
    pub mag: u32
    pub sign: bool
}

const TWO: u32 = 131072 // 2 ** 17
const ONE: u32 = 65536 // 2 ** 16
const HALF: u32 = 32768 // 2 ** 15
const MAX: u32 = 2147483648 // 2 ** 31


pub trait FixedTrait {
    fn new(mag: u32, sign: bool) -> Self;
    fn new_unscaled(mag: u32, sign: bool) -> Self;
    fn one() -> Self;
    fn convert_to_u32(self) -> u32;
    fn abs(self) -> Self;
    fn floor(self) -> Self;
    fn ceil(self) -> Self;
    fn round(self) -> Self;
    fn negate(self) -> Self;

    fn add(self, other: Self) -> Self;
    fn sub(self, other: Self) -> Self;
    fn mul(self, other: Self) -> Self;
    fn div(self, other: Self) -> Self;

    fn eq(self, other: Self) -> bool;
    fn ge(self, other: Self) -> bool;
    fn gt(self, other: Self) -> bool;
    fn le(self, other: Self) -> bool;
    fn lt(self, other: Self) -> bool;
    fn ne(self, other: Self) -> bool;
    // fn exp(self) -> Self;
    // fn log2(self) -> Self;
}

impl FixedTrait for FP16x16 {
  fn new(mag: u32, sign: bool) -> Self {
    return FP16x16(mag: mag, sign: sign)
  }
  fn new_unscaled(mag: u32, sign: bool) -> Self {
    return FP16x16(mag: mag << 16, sign: sign)
  }
  fn one() -> Self {
    return FP16x16(mag: ONE, sign: false)
  }
  fn convert_to_u32(self) -> u32 {
    return self.mag >> 16
  }
  fn abs(self) -> Self {
    return FP16x16(mag: self.mag, sign: true)
  }
  // You will get floor to the nearest integer
  fn floor(self) -> Self {
    if self.sign {
      return FP16x16(mag: self.mag & 0xFFFF0000 + ONE, sign: self.sign)
    } else {
      return FP16x16(mag: self.mag & 0xFFFF0000, sign: self.sign)
    }
  }
  fn ceil(self) -> Self {
    if self.sign {
      return FP16x16(mag: self.mag & 0xFFFF0000, sign: self.sign)
    } else {
      return FP16x16(mag: self.mag & 0xFFFF0000 + ONE, sign: self.sign)
    }
  }
  fn round(self) -> Self {
    let value: u32 = self.mag & 0x00008000
    if value == 0{
      return FP16x16(mag: self.mag & 0xFFFF0000, sign: self.sign)
    } else {
      return FP16x16(mag: self.mag & 0xFFFF0000 + ONE, sign: self.sign)
    }
  }

  fn add(self, _ other: FP16x16) -> Self {
    if self.sign == other.sign {
      return FP16x16(mag: self.mag + other.mag, sign: self.sign)
    } else {
      if self.mag > other.mag {
        return FP16x16(mag: self.mag - other.mag, sign: self.sign)
      } else {
        return FP16x16(mag: other.mag - self.mag, sign: other.sign)
      }
    }
  }

  fn negate(self) -> Self {
    return FP16x16(mag: self.mag, sign: not self.sign)
  }

  fn sub(self, _ other: FP16x16) -> Self {
    return self.add(other.negate())
  }

  fn mul(self, _ other: FP16x16) -> Self {
    // let res: u64 = u32_wide_mul(self.mag, other.mag)
    let first : u32 = self.mag / ONE
    // Use wide mul for better precision
    let res: u32 = first * other.mag
    let sign: bool = xor(self.sign, other.sign)

    return FP16x16(mag: res, sign: sign)
  }

  // fn mul(self, other: FP16x16) -> {
  //   // Make sure that the result is not too big
  //   assert self.mag < MAX
  //   assert other.mag < MAX

  //   let (a, b) = u32_divmod(self.mag, ONE)
  //   let (c, d) = u32_divmod(other.mag, ONE)

  //   let ac = a * c
  //   let ad = a * d
  //   let bc = b * c
  //   let bd = b * d

  //   let adbc = ad + bc
  //   let adbc_shifted = adbc >> 16
  //   let adbc_shifted = adbc_shifted + HALF 
  //   let adbc_shifted = adbc_shifted >> 16

  //   let result = ac + adbc_shifted

  //   return FP16x16(mag: result, sign: self.sign ^ other.sign)
  // }

  fn div(self, other: FP16x16) -> FP16x16 {
    // Use wide mul for better precision
    let first : u32 = self.mag / ONE
    // Use wide mul for better precision
    let res: u32 = first / other.mag
    let sign: bool = xor(self.sign, other.sign)

    return FP16x16(mag: res, sign: sign)
  }

  fn eq(self, other: FP16x16) -> bool {
    return self.mag == other.mag and self.sign == other.sign
  }

  fn ge(self, other: FP16x16) -> bool {
    if self.sign == false and other.sign == true {
      return true
    } else if self.sign == true and other.sign == false {
      return false
    } else if self.sign == false and other.sign == false {
      return self.mag >= other.mag
    } else {
      return self.mag <= other.mag
    }
  }

  fn gt(self, other: FP16x16) -> bool {
    if self.sign == false and other.sign == true {
      return true
    } else if self.sign == true and other.sign == false {
      return false
    } else if self.sign == false and other.sign == false {
      return self.mag > other.mag
    } else {
      return self.mag < other.mag
    }
  }

  fn le(self, other: FP16x16) -> bool {
    if self.sign == false and other.sign == true {
      return false
    } else if self.sign == true and other.sign == false {
      return true
    } else if self.sign == false and other.sign == false {
      return self.mag <= other.mag
    } else {
      return self.mag >= other.mag
    }
  }

  fn lt(self, other: FP16x16) -> bool {
    if self.sign == false and other.sign == true {
      return false
    } else if self.sign == true and other.sign == false {
      return true
    } else if self.sign == false and other.sign == false {
      return self.mag < other.mag
    } else {
      return self.mag > other.mag
    }
  }

  fn ne(self, other: FP16x16) -> bool {
    return self.mag != other.mag or self.sign != other.sign
  }

  // fn log2(self) -> Self {
  //   assert self.sign == false // log2 is only defined for positive numbers

  //   if self.mag == ONE {
  //     return FP16x16(mag: 0, sign: false)
  //   } else if self.mag < ONE {

  //   }
  // }
}

pub fn u32_wide_mul(_ a: u32, _ b: u32) -> u64{
    let first: u64 = a;
    let second: u64 = b;
    let result: u64 = a * b;
    return result;
}

pub fn u32_divmod(_ a: u32, _ b: u32) -> (u32, u32) {
    return (a / b, a % b)
}

pub fn xor(_ a: bool, _ b: bool) -> bool {
    if a == b {
        return true;
    } else {
        return false;
    }
}